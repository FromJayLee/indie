{
  "rules": [
    {
      "type": "prd",
      "content": "# 우주 픽셀아트 감상 웹사이트 PRD\n\n## 1. 제품 개요\n산나비(SANNABI) 스타일의 고해상도 픽셀아트로 구현된 우주 공간을 웹에서 실시간으로 감상할 수 있는 서비스. 혜성, 유성, 우주선, 인공위성 등이 랜덤하게 떠다니며, 광고주 로고가 그려진 오브젝트를 삽입해 자연스럽게 수익화를 노린다.\n\n## 2. 제품 비전\n“누구나 클릭 한 번으로 가장 아름다운 픽셀 우주를 여행하게 하고, 브랜드에는 몰입형 광고 무대를 제공한다.”\n\n## 3. 목표\n1. 방문자 평균 체류시간 5분 이상 달성 (MVP 1개월 내)\n2. 재방문률 15% 이상 확보 (MVP 1개월 내)\n3. 광고주 3곳 이상 파일럿 계약 체결 (런칭 3개월 내)\n\n## 4. 대상 사용자\n- 픽셀아트·게임 감성에 끌리는 일반 웹 이용자\n- 시각적 힐링·킬링타임용 콘텐츠를 찾는 대중\n- 브랜드·마케터(2차 고객) – 크리에이티브 광고 슬롯 탐색자\n\n## 5. 사용자의 문제점(Pain Point)\n고퀄리티·인터랙티브 시각 콘텐츠를 웹에서 빠르게 즐길 선택지가 부족하다.\n\n## 6. 핵심 가치 제안\n- 고해상도 픽셀아트 + 부드러운 WebGL 애니메이션으로 즉각적 몰입 제공\n- 브랜드 로고가 자연스럽게 등장하는 ‘새로운’ 광고 경험\n\n## 7. 주요 기능(스코프)\n| 분류 | 기능 | MVP 포함 여부 |\n|------|------|---------------|\n| 핵심 | 랜덤 생성·실시간 애니메이션 우주 맵 | ✅ |\n| 핵심 | 광고 로고 삽입 우주선·인공위성 표시 | ✅ |\n| 지원 | SNS 공유용 스크린샷 버튼 | ❌ (V2) |\n| 지원 | 배경 음악·효과음 토글 | ❌ (V2) |\n| 지원 | 오브젝트 클릭 정보 팝업 | ❌ (V2) |\n\n## 8. 기능 상세\n1. 랜덤 우주 맵 렌더링\n   - 캔버스·WebGL 기반으로 60fps 목표\n   - 오브젝트 50개 이내 동시 표시 → 퍼포먼스 최적\n2. 광고 로고 오브젝트\n   - 이미지 sprite 교체 방식으로 로고 삽입\n   - 관리자 화면 없이 JSON 설정 파일로 초기 관리(MVP)\n\n## 9. 마일스톤 & 일정(예시)\n- 주간 1스프린트, 총 4주\n  1주차: 아트 리소스 준비, 랜더러 POC\n  2주차: 애니메이션 시스템, 오브젝트 스폰 로직\n  3주차: 광고 로고 오브젝트 연결, 반응형 레이아웃\n  4주차: 테스트·배포, 기본 GA 수집\n\n## 10. 성공 지표(북극성 지표 & KPI)\n- 북극성 지표: ‘평균 세션 체류시간’\n- KPI\n  - 세션 체류시간 ≥ 5분\n  - 재방문률 ≥ 15%\n  - 광고 노출 당 뷰어블 100% (화면 내 시간 ≥ 2초)\n\n## 11. 주요 가정 & 리스크\n- 고해상도 픽셀아트도 WebGL 최적화로 모바일 30fps 이상 가능\n- 초기 트래픽은 SNS 바이럴로 유입 가능\n- 광고주는 새로운 광고 포맷에 호기심이 있다\n\n## 12. 기술 스택(기본)\nNext.js 15, Typescript, TailwindCSS, shadcn, lucide-react, supabase, @tanstack/react-query, date-fns\n\n## 13. 수익 모델\n- 브랜드 로고 삽입 오브젝트 1개당 월 정액 과금 (파일럿: 무료/할인)\n\n## 14. 향후 로드맵(포스트 MVP)\n- SNS 공유 기능\n- 배경음·효과음 옵션\n- 관리자 대시보드 & 광고주별 리포트\n- 모바일 앱(React Native or Expo)",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "architecture",
      "content": "Of course. Here is the refined, lean, and implementation-focused Technical Requirements Document (TRD) based on the provided PRD. It strictly removes over-engineering and prioritizes clarity for building the MVP.\n\n---\n\n# **Technical Requirements Document (TRD): Pixel Space MVP**\n\n## 1. Technical Overview\n\nThis document outlines the technical specifications for building the \"Pixel Space\" web application MVP. The core objective is to create a performant, full-screen, real-time 2D animation of a pixel-art universe using WebGL.\n\n-   **Core Architecture**: A static single-page application (SPA) built with Next.js, serving a primary WebGL canvas managed by PixiJS.\n-   **Key Technical Goal**: Achieve smooth 60fps animation on desktop and a stable 30fps on modern mobile devices by optimizing sprite rendering.\n-   **Configuration**: All dynamic elements, including advertisement objects, will be managed via a local JSON configuration file for the MVP. No backend database or admin panel is required.\n\n## 2. Technology Stack (MVP)\n\nThis stack is the minimal set required to deliver the core experience.\n\n| Category             | Technology      | Rationale                                                                        |\n| -------------------- | --------------- | -------------------------------------------------------------------------------- |\n| Framework            | Next.js         | Provides a robust React foundation, optimized static builds, and easy deployment.  |\n| Language             | TypeScript      | Ensures type safety for managing complex animation logic and object states.      |\n| **Rendering Engine** | **PixiJS**      | **Primary technology.** A high-performance 2D WebGL renderer ideal for sprite-based games and animations. Abstracts away WebGL complexity. |\n| Styling              | TailwindCSS     | For minimal UI layout around the canvas (e.g., centering, background color).     |\n| Deployment           | Vercel          | Native, zero-configuration deployment for Next.js with global CDN for fast asset delivery. |\n\n***Note on Exclusions:*** *Complex state management libraries (Redux, Zustand), UI component libraries (shadcn/ui), and data-fetching libraries (@tanstack/react-query) are unnecessary for the MVP, as there is no complex UI or server state to manage.*\n\n## 3. System Architecture\n\n### 3.1. Simplified Architecture\n\nThe MVP operates as a client-side-only application.\n\n```mermaid\ngraph TD\n    subgraph Browser\n        A[User] --> B{Next.js Page}\n        B -- loads --> C[SpaceCanvas React Component]\n        C -- initializes --> D[PixiJS Application]\n        B -- reads --> E[config/advertisements.json]\n        E -- provides data to --> D\n        D -- renders sprites to --> F[HTML Canvas Element]\n    end\n```\n\n### 3.2. Data & Asset Flow\n\n1.  **Initial Load**: The user loads the Next.js page. The application bundle, including art assets (sprites) and the JSON configuration, is downloaded.\n2.  **Initialization**: The main React component mounts the PixiJS canvas.\n3.  **Configuration**: The application reads `config/advertisements.json` to get the list of sponsored objects and their logo URLs.\n4.  **Rendering Loop**: The PixiJS engine starts its main loop (`ticker`).\n5.  **Spawning Logic**: The engine periodically spawns objects (comets, generic ships, sponsored ships) at random positions off-screen, assigning them random trajectories. Sponsored objects are chosen based on the loaded configuration.\n6.  **Animation**: All objects are moved across the canvas each frame. The engine uses GPU-accelerated rendering for performance.\n\n### 3.3. File Structure\n\nA lean structure focused on the core rendering logic.\n\n```\n/\n├── public/\n│   ├── sprites/\n│   │   ├── spaceship.png\n│   │   ├── comet.png\n│   │   └── sponsored/\n│   │       └── [logo_from_config].png\n│   └── background.png\n├── src/\n│   ├── app/\n│   │   ├── page.tsx           # Main page that hosts the canvas\n│   │   └── layout.tsx         # Root layout\n│   ├── components/\n│   │   └── space/\n│   │       ├── SpaceCanvas.tsx  # React component wrapper for PixiJS\n│   │       └── engine/          # Core PixiJS logic\n│   │           ├── main.ts      # Engine setup, main loop\n│   │           ├── objects.ts   # Object classes (Comet, Ship)\n│   │           └── spawner.ts   # Logic for creating objects\n│   └── config/\n│       └── advertisements.json  # Ad configuration\n```\n\n## 4. Core Technical Requirements\n\n### 4.1. Rendering Engine\n\n-   **Canvas**: A single `<canvas>` element managed by PixiJS must fill 100% of the browser's viewport.\n-   **Renderer**: Use `PixiJS.Application` with `autoDensity` enabled for high-resolution displays.\n-   **Performance**:\n    -   Target **60 FPS** on desktop and **30 FPS** on mobile.\n    -   Utilize **Sprite Batching** (native in PixiJS) to minimize draw calls.\n    -   Implement **Object Pooling** for creating and destroying objects to reduce garbage collection overhead.\n-   **Object Limit**: A hard limit of **50** concurrent objects on screen must be enforced to maintain performance.\n\n### 4.2. Object & Animation Logic\n\n-   **Spawning**: Objects must be spawned off-screen and travel across the viewport.\n-   **Movement**: Each object will have a simple linear velocity vector. No complex physics is required.\n-   **Despawning**: Objects that move outside the viewport boundaries must be removed from the stage and returned to the object pool.\n\n### 4.3. Advertisement Integration\n\n-   The system will be driven by a static JSON file: `src/config/advertisements.json`.\n-   This file will contain an array of ad objects.\n-   The rendering engine will parse this file on startup and load the specified ad logos as textures for designated object types (e.g., \"sponsored spaceship\").\n\n#### `advertisements.json` Schema:\n\n```json\n[\n  {\n    \"id\": \"sponsor-01\",\n    \"name\": \"Sponsor Name A\",\n    \"logoUrl\": \"/sprites/sponsored/logo-a.png\",\n    \"objectType\": \"spaceship_premium\",\n    \"spawnWeight\": 50\n  },\n  {\n    \"id\": \"sponsor-02\",\n    \"name\": \"Sponsor Name B\",\n    \"logoUrl\": \"/sprites/sponsored/logo-b.png\",\n    \"objectType\": \"satellite\",\n    \"spawnWeight\": 30\n  }\n]\n```\n\n## 5. Out of Scope for MVP\n\nTo ensure a focused 4-week delivery, the following features are explicitly excluded:\n\n-   **NO** user interaction (clicking objects, panning, zooming).\n-   **NO** audio (background music or sound effects).\n-   **NO** UI overlays (buttons, menus, popups).\n-   **NO** backend or database integration (e.g., Supabase).\n-   **NO** server-side rendering of the canvas state.\n-   **NO** admin dashboard for managing advertisements.\n\n## 6. Key Risks & Mitigation\n\n| Risk                                    | Mitigation Strategy                                                                                             |\n| --------------------------------------- | --------------------------------------------------------------------------------------------------------------- |\n| **Performance Bottlenecks** on mobile or low-end devices. | Strictly enforce the 50-object limit. Use texture atlases (sprite sheets) to reduce texture swaps. Profile performance on target devices early and continuously. |\n| **Browser Compatibility** issues with WebGL. | Rely on PixiJS's robust cross-browser support. Confirm functionality on latest versions of Chrome, Firefox, and Safari. A non-functional state is acceptable on legacy browsers. |\n| **Asset Loading Time** impacts user experience. | Compress all PNG assets using tools like TinyPNG. Ensure the total initial asset payload is under 2MB. |",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "design-guide",
      "content": "# 우주 픽셀아트 감상 웹사이트 Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\n이 서비스는 **레트로 퓨처리즘**과 **사이버펑크** 미학을 결합한 혁신적이고 미래지향적인 분위기를 추구합니다. 산나비(SANNABI)와 카타나 제로(Katana ZERO)에서 영감을 받은 네온 사이버 미학을 통해 깊은 우주 공간에서 펼쳐지는 고대비 픽셀아트 세계를 구현합니다.\n\n핵심 컨셉은 **\"어둠 속에서 빛나는 네온의 우주\"**로, 깊은 네이비 우주 배경에 전기적인 블루와 네온 퍼플이 강렬하게 대비되어 몰입감 있는 시각적 경험을 제공합니다. 사용자가 마치 미래의 우주 관측소에서 픽셀 우주를 관찰하는 듯한 느낌을 전달하며, 브랜드 광고 오브젝트들이 자연스럽게 우주 환경에 녹아들도록 설계됩니다.\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Katana ZERO\n- **Description**: 사이버펑크 스타일의 2D 액션 게임으로 네온 컬러와 픽셀아트의 완벽한 조화를 보여주는 작품\n- **Design Mood**: 어두운 배경에 강렬한 네온 컬러가 대비되는 사이버펑크 미학, 고해상도 픽셀아트와 부드러운 애니메이션의 조화\n- **Primary Color**: #3AB5FF (Electric Blue)\n- **Secondary Color**: #B486FF (Neon Purple)\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n### 메인 컬러 팔레트\n- **Primary Color**: #3AB5FF (Electric Blue) - 네온 블루, 주요 UI 요소와 로고에 사용\n- **Secondary Color**: #B486FF (Neon Purple) - 네온 퍼플, 보조 요소와 그림자 효과에 사용\n- **Background Color**: #0B0F26 (Deep Space Navy) - 깊은 우주를 표현하는 메인 배경색\n- **Accent Color**: #B2FF59 (Acid Lime) - 강조 및 하이라이트 요소에 사용\n- **Text Color**: #F5F7FF (Ghost White) - 텍스트와 아이콘에 사용하는 밝은 색상\n\n### 무드 및 사용법\n- **Mood**: Cool톤 기반의 고채도 네온 컬러로 미래적이고 신비로운 분위기 연출\n- **Color Usage**: \n  - 최우선 요소: Electric Blue (#3AB5FF) - 로고, 주요 버튼, 핵심 오브젝트\n  - 2순위 요소: Neon Purple (#B486FF) - 보조 UI, 그림자, 서브 오브젝트\n  - 강조 요소: Acid Lime (#B2FF59) - 브랜드 광고 오브젝트 테두리, 호버 상태\n  - 배경: Deep Space Navy (#0B0F26) - 전체 배경, 컨테이너\n  - 텍스트: Ghost White (#F5F7FF) - 모든 텍스트 요소\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n### 폰트 시스템\n- **Heading 1**: \"Press Start 2P\" 또는 \"VT323\", 24px, Bold - 로고 및 메인 타이틀용 레트로 픽셀 폰트\n- **Heading 2**: Inter, 20px, SemiBold - 섹션 제목\n- **Body**: Inter, 16px (데스크톱), 14px (모바일), Regular - 본문 텍스트\n- **Caption**: Inter, 12px, Regular - 작은 설명 텍스트\n\n### 타이포그래피 규칙\n- 네비게이션 항목은 모두 대문자(ALL CAPS) 사용\n- 사이버 룩을 위해 약간의 음수 letter-spacing (-0.02em) 적용\n- 줄 간격(line-height)은 1.5배수 기본 사용\n- 픽셀 폰트는 안티앨리어싱 비활성화로 선명한 픽셀 효과 유지\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n### 기본 레이아웃\n- **전체 화면 캔버스**: 뷰포트 전체를 차지하는 단일 캔버스 구조\n- **상단 바**: 56px 높이의 고정 투명 바, 미묘한 blur 효과 적용\n  - 좌측: Electric Blue 컬러의 로고 워드마크\n  - 우측: Ghost White 컬러의 작은 정보 아이콘 (선택사항)\n\n### 그리드 시스템\n- 픽셀아트 오브젝트: 12×12 또는 24×24 그리드 기준\n- 레티나 디스플레이 대응을 위한 @2x 해상도 내보내기\n- 캔버스는 디바이스 픽셀 비율에 맞춰 스케일링, 필요시 레터박스 적용\n\n### 반응형 설계\n- **모바일**: 상단 바 48px로 축소, 로고 중앙 정렬\n- **태블릿/데스크톱**: 기본 56px 상단 바 유지\n- 모든 디바이스에서 캔버스 비율 유지\n\n## 6. Visual Style (비주얼 스타일)\n\n### 아트 스타일 가이드\n- **픽셀아트 해상도**: 96-128px 프레임 크기의 고해상도 픽셀 스프라이트\n- **컬러 제한**: 스프라이트당 5-7가지 색상으로 메인 컬러 스킴 준수\n- **네온 글로우**: 셰이더 블룸 또는 외곽 글로우 스프라이트 오버레이로 네온 효과 구현\n\n### 아이콘 시스템\n- Lucide-react 아이콘 라이브러리 사용\n- Ghost White (#F5F7FF) 색상으로 틴팅\n- 24px 기본 크기, 미니멀한 UI 요소에만 사용\n\n### 이미지 처리\n- 모든 우주 오브젝트는 고해상도 픽셀 스프라이트로 렌더링\n- 브랜드 로고 오브젝트는 Acid Lime 테두리로 자연스럽게 강조\n- 안티앨리어싱 없는 픽셀 퍼펙트 렌더링\n\n## 7. UX Guide (UX 가이드)\n\n### 타겟 사용자별 UX 전략\n**초심자 (일반 웹 이용자)**:\n- 직관적인 원클릭 접근: 별도 설명 없이 즉시 우주 감상 가능\n- 3초 이내 로딩으로 즉각적인 만족감 제공\n- 마우스 움직임만으로도 충분한 인터랙션 경험\n\n**전문가 (픽셀아트 애호가)**:\n- 60fps 목표의 부드러운 WebGL 애니메이션\n- 고해상도 픽셀아트의 디테일을 명확히 감상할 수 있는 화질\n- 레트로 게임 감성을 자극하는 사운드 및 비주얼 효과 (V2)\n\n### 핵심 UX 원칙\n1. **즉시성**: 로딩 시간 최소화, 바로 보이는 시각적 임팩트\n2. **몰입감**: 전체 화면 캔버스로 완전한 우주 경험 제공\n3. **자연스러움**: 광고 오브젝트의 비침해적 통합\n4. **접근성**: 모든 디바이스에서 일관된 경험\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 상단 네비게이션 바\n- **배경**: 투명 배경에 backdrop-blur-sm 효과\n- **높이**: 56px (데스크톱), 48px (모바일)\n- **로고**: Press Start 2P 폰트, Electric Blue (#3AB5FF) 색상\n- **아이콘**: 24px Lucide 아이콘, Ghost White (#F5F7FF) 색상\n\n### 로딩 컴포넌트\n- **애니메이션**: 픽셀 혜성 스프라이트의 회전 애니메이션\n- **색상**: Electric Blue에서 Neon Purple로 그라데이션\n- **지속시간**: 최대 3초, 부드러운 페이드아웃\n\n### 캔버스 인터페이스\n- **렌더링**: WebGL 기반 60fps 목표\n- **오브젝트 이동**: 20-100 px/sec 다양한 속도, 랜덤 이징 패스\n- **패럴랙스**: 2-3개 레이어로 깊이감 구현\n- **카메라**: 흔들림 없는 고정 시점, 부드러운 패럴랙스만 적용\n\n### 브랜드 광고 오브젝트\n- **테두리**: Acid Lime (#B2FF59) 1px 외곽선\n- **애니메이션**: 기본 우주 오브젝트와 동일한 자연스러운 움직임\n- **크기**: 96-128px 표준 스프라이트 크기\n- **가시성**: 화면 내 2초 이상 머물 때 100% 뷰어블 달성\n\n### 반응형 적응\n- **모바일 최적화**: 30fps 이상 유지를 위한 성능 최적화\n- **터치 인터랙션**: 마우스 움직임을 터치 제스처로 대체\n- **뷰포트 적응**: 다양한 화면 비율에서 레터박스 처리\n\n### 접근성 고려사항\n- **대비비**: 모든 텍스트 요소 4.5:1 이상 대비비 확보\n- **모션 감소**: 설정에서 애니메이션 감소 옵션 제공 (V2)\n- **키보드 네비게이션**: 탭 순서 및 포커스 표시 명확화\n- **스크린 리더**: 캔버스 콘텐츠에 대한 적절한 alt 텍스트 제공",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "ia",
      "content": "# 우주 픽셀아트 감상 웹사이트 Information Architecture (IA)\n\n## 1. 사이트맵 (사이트맵)\n\n```\n우주 픽셀아트 감상 웹사이트\n├── 홈 (메인 우주 캔버스)\n├── 정보 모달\n│   ├── 서비스 소개\n│   ├── 사용법 안내\n│   └── 브랜드 문의\n└── 설정 모달 (V2)\n    ├── 음향 설정\n    ├── 성능 설정\n    └── 접근성 설정\n```\n\n## 2. 사용자 흐름 (사용자 흐름)\n\n### 핵심 작업: 우주 감상 및 브랜드 발견\n1. 사용자가 SNS 링크를 통해 사이트 접속\n2. 3초 이내 우주 캔버스 로딩 완료\n3. 자동으로 픽셀 우주 애니메이션 시작\n4. 마우스 움직임으로 시각적 피드백 경험\n5. 브랜드 로고가 포함된 우주선/위성 발견\n6. 5분 이상 자연스럽게 감상 지속\n7. URL 복사하여 지인과 공유\n\n### 보조 작업: 서비스 정보 확인\n1. 상단 정보 아이콘 클릭\n2. 서비스 소개 모달 팝업\n3. 사용법 또는 브랜드 문의 탭 이동\n4. 모달 닫기로 우주 감상 재개\n\n### 광고주 작업 흐름 (V2)\n1. 브랜드 문의 섹션 접근\n2. 연락처 정보 입력\n3. 로고 파일 업로드\n4. 파일럿 신청 완료\n\n## 3. 네비게이션 구조 (네비게이션 구조)\n\n### 글로벌 네비게이션 바 (GNB)\n- **위치**: 화면 상단 고정 (56px 높이)\n- **배경**: 투명 배경 + backdrop-blur 효과\n- **구성 요소**:\n  - 좌측: \"PIXEL SPACE\" 로고 워드마크 (Electric Blue)\n  - 우측: 정보 아이콘 (Ghost White, 24px)\n\n### 모달 네비게이션\n- **정보 모달 탭**: 서비스 소개 | 사용법 안내 | 브랜드 문의\n- **설정 모달 탭 (V2)**: 음향 설정 | 성능 설정 | 접근성 설정\n\n### 모바일 네비게이션\n- **상단 바 높이**: 48px로 축소\n- **로고**: 중앙 정렬\n- **정보 아이콘**: 우측 하단 플로팅 버튼으로 이동\n\n## 4. 페이지 계층 구조 (페이지 계층 구조)\n\n```\n/ (Depth 1) - 메인 우주 캔버스\n├── /modal/info (Depth 2) - 정보 모달\n│   ├── /modal/info#about (Depth 3) - 서비스 소개 탭\n│   ├── /modal/info#guide (Depth 3) - 사용법 안내 탭\n│   └── /modal/info#contact (Depth 3) - 브랜드 문의 탭\n└── /modal/settings (Depth 2) - 설정 모달 (V2)\n    ├── /modal/settings#audio (Depth 3) - 음향 설정 탭\n    ├── /modal/settings#performance (Depth 3) - 성능 설정 탭\n    └── /modal/settings#accessibility (Depth 3) - 접근성 설정 탭\n```\n\n## 5. 콘텐츠 구성 (콘텐츠 구성)\n\n| 페이지 | 주요 콘텐츠 요소 |\n|---|---|\n| 메인 홈 | 전체 화면 WebGL 캔버스, 픽셀 우주 오브젝트, 브랜드 광고 오브젝트, 로딩 애니메이션 |\n| 서비스 소개 | 서비스 비전 텍스트, 픽셀아트 스크린샷, 주요 기능 리스트 |\n| 사용법 안내 | 마우스 인터랙션 가이드, 브랜드 오브젝트 설명, 공유 방법 안내 |\n| 브랜드 문의 | 연락처 입력 폼, 로고 업로드 영역, 파일럿 프로그램 소개 |\n| 음향 설정 (V2) | 배경음악 볼륨 슬라이더, 효과음 on/off 토글, 음소거 버튼 |\n| 성능 설정 (V2) | FPS 제한 선택, 오브젝트 수 조절, 품질 프리셋 선택 |\n| 접근성 설정 (V2) | 모션 감소 토글, 고대비 모드, 스크린 리더 지원 활성화 |\n\n## 6. 인터랙션 패턴 (인터랙션 패턴)\n\n### 기본 인터랙션\n- **마우스 움직임**: 캔버스 내 시차 효과 및 오브젝트 반응\n- **클릭 인터랙션**: 모달 열기/닫기, 탭 전환\n- **호버 효과**: 네비게이션 요소에 Acid Lime 컬러 글로우\n- **터치 제스처**: 모바일에서 스와이프로 시차 효과 구현\n\n### 모달 패턴\n- **오버레이**: Deep Space Navy 80% 투명도 배경\n- **애니메이션**: 0.3초 fade-in/scale-up 효과\n- **닫기 방법**: X 버튼 클릭, ESC 키, 오버레이 클릭\n- **포커스 트랩**: 모달 내부 요소로 포커스 제한\n\n### 피드백 패턴\n- **로딩 상태**: 픽셀 혜성 회전 애니메이션\n- **에러 상태**: Acid Lime 컬러 경고 메시지\n- **성공 상태**: Electric Blue 컬러 확인 메시지\n- **진행 상태**: 그라데이션 프로그레스 바\n\n## 7. URL 구조 (URL 구조)\n\n### 메인 페이지\n- **홈**: `/` - 메인 우주 캔버스 화면\n- **공유용 단축 URL**: `/s/:shareId` - SNS 공유 최적화\n\n### 모달 상태 URL (SPA 내 상태 관리)\n- **정보 모달**: `/#info` - 서비스 정보 모달 열림 상태\n- **설정 모달**: `/#settings` - 설정 모달 열림 상태 (V2)\n- **탭 상태**: `/#info/about`, `/#info/guide`, `/#info/contact`\n\n### SEO 최적화 규칙\n- **메타 태그**: 동적으로 픽셀 우주 스크린샷 생성\n- **Open Graph**: 브랜드별 맞춤 미리보기 이미지\n- **구조화 데이터**: Creative Work 스키마 적용\n\n## 8. 컴포넌트 계층 구조 (컴포넌트 계층 구조)\n\n### 글로벌 컴포넌트\n- **Header**: 로고, 정보 아이콘이 포함된 상단 네비게이션\n- **Canvas**: WebGL 기반 우주 렌더링 캔버스\n- **LoadingSpinner**: 픽셀 혜성 애니메이션 로더\n- **Modal**: 재사용 가능한 모달 컨테이너\n- **Toast**: 알림 메시지 표시 컴포넌트\n\n### 우주 캔버스 컴포넌트\n- **SpaceRenderer**: WebGL 렌더링 엔진\n- **SpaceObject**: 기본 우주 오브젝트 (혜성, 유성, 별)\n- **BrandObject**: 브랜드 로고가 포함된 광고 오브젝트\n- **ParallaxLayer**: 시차 효과 레이어 관리\n- **AnimationController**: 오브젝트 움직임 제어\n\n### 모달 특화 컴포넌트\n- **InfoModal**: 서비스 정보 표시 모달\n- **ContactForm**: 브랜드 문의 폼 컴포넌트\n- **SettingsPanel**: 설정 옵션 패널 (V2)\n- **TabContainer**: 모달 내 탭 네비게이션\n- **FileUpload**: 로고 파일 업로드 컴포넌트\n\n### 유틸리티 컴포넌트\n- **Button**: 네온 스타일 버튼 (Primary, Secondary, Ghost)\n- **Input**: 사이버펑크 스타일 입력 필드\n- **Toggle**: 설정용 온/오프 스위치\n- **Slider**: 볼륨 등 수치 조절 슬라이더\n- **Icon**: Lucide 아이콘 래퍼 컴포넌트\n\n### 반응형 컴포넌트\n- **MobileHeader**: 모바일 전용 헤더 레이아웃\n- **TouchController**: 모바일 터치 인터랙션 처리\n- **ResponsiveCanvas**: 디바이스별 캔버스 최적화\n- **FloatingButton**: 모바일 플로팅 액션 버튼",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-13T07:14:49.350Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-13T07:14:49.350Z"
    }
  ]
}